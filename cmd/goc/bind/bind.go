// Copyright (c) 2016-2019, Andreas T Jonsson
// All rights reserved.

package bind

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"time"
)

type TypeSpec struct {
	GoType, CType string
}

type FuncBinding struct {
	Comment,
	Call string
	Args        []string
	Ret         string
	Block, Safe bool
}

var allTypes = map[string]TypeSpec{}

func Bind() int {
	setupFlags()
	inputPaths := flag.Args()
	if len(inputPaths) < 1 {
		fmt.Fprintln(os.Stderr, "no source")
		return -1
	}

	// Start looking for types.
	if err := filepath.Walk(inputPaths[0], func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.Mode().IsRegular() {
			dir := filepath.Clean(filepath.Dir(path))

			if info.Name() == "goc.type" {
				fp, err := os.Open(path)
				if err != nil {
					return err
				}
				defer fp.Close()

				var types map[string]TypeSpec
				dec := json.NewDecoder(fp)
				if err := dec.Decode(&types); err != nil {
					return err
				}

				for name, ty := range types {
					allTypes[filepath.Join(dir, name)] = ty
				}
			}
		}

		return nil
	}); err != nil {
		fmt.Fprintln(os.Stderr, err)
		return -1
	}

	// Search for bindings.
	if err := filepath.Walk(inputPaths[0], func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.Mode().IsRegular() {
			dir := filepath.Clean(filepath.Dir(path))

			if info.Name() == "goc.bind" {
				fp, err := os.Open(path)
				if err != nil {
					return err
				}
				defer fp.Close()

				var bindings map[string]FuncBinding
				dec := json.NewDecoder(fp)
				if err := dec.Decode(&bindings); err != nil {
					return err
				}

				if err := generate(dir, bindings); err != nil {
					return nil
				}
			}
		}

		return nil
	}); err != nil {
		fmt.Fprintln(os.Stderr, err)
		return -1
	}

	return 0
}

func generate(dir string, bindings map[string]FuncBinding) error {
	logln("Generate:", dir)

	fpg, err := os.Create(filepath.Join(dir, "bind_goc.go"))
	if err != nil {
		return err
	}
	defer fpg.Close()

	fps, err := os.Create(filepath.Join(dir, "bind_goc.s"))
	if err != nil {
		return err
	}
	defer fps.Close()

	pkg := filepath.Base(dir)

	fmt.Fprint(fps, "// +build goc\n\n")
	fmt.Fprint(fps, "// Generated by the GopherC bind tool.\n\n")
	fmt.Fprintf(fps, "#include \"textflag.h\"\n\n")

	fmt.Fprint(fpg, "// Generated by the GopherC bind tool.\n")
	fmt.Fprintf(fpg, "// %v\n\n", time.Now())
	fmt.Fprint(fpg, "// +build goc\n\n")
	fmt.Fprintf(fpg, "package %s\n\n", pkg)

	for funcName, bind := range bindings {
		logvln(funcName, "->", bind.Call)

		fmt.Fprintf(fps, "TEXT Â·goc%s(SB), NOSPLIT, $0\n\tCallImport\n\tRET\n\n", funcName)

		fmt.Fprintf(fpg, "func goc%s(", funcName)

		writeArgs := func(isCall bool) {
			fullFuncName := filepath.Join(dir, funcName)
			if len(bind.Args)%2 != 0 {
				fmt.Fprintf(os.Stderr, "%s has invalid arguments\n", fullFuncName)
			}

			for i := 0; i < len(bind.Args); i += 2 {
				name := bind.Args[i]
				ty := bind.Args[i+1]

				if i > 0 {
					fmt.Fprint(fpg, ", ")
				}

				if isCall {
					fmt.Fprint(fpg, name)
				} else {
					fmt.Fprintf(fpg, "%s ", name)

					fullName := filepath.Join(dir, ty)
					typeSpec, ok := allTypes[fullName]
					if !ok {
						fmt.Fprintf(os.Stderr, "%s has invalid argument type: %s\n", fullFuncName, fullName)
					}

					fmt.Fprint(fpg, typeSpec.GoType)
				}
			}
		}

		writeArgs(false)
		fmt.Fprint(fpg, ")\n\n")

		if bind.Comment != "" {
			fmt.Fprintf(fpg, "// %s\n", bind.Comment)
		}

		fmt.Fprintf(fpg, "func %s(", funcName)
		writeArgs(false)
		fmt.Fprintf(fpg, ") {\n\tgoc%s(", funcName)
		writeArgs(true)
		fmt.Fprint(fpg, ")\n}\n\n")
	}

	return nil
}

func logln(a ...interface{}) {
	if !silent {
		fmt.Println(a...)
	}
}

func logvln(a ...interface{}) {
	if !silent && verbose {
		fmt.Println(a...)
	}
}

func About() string {
	return "generate C bindings"
}

var (
	gocRoot = os.Getenv("GOCROOT")

	silent,
	verbose bool
)

func setupFlags() {
	var exePath string
	if path, err := os.Executable(); err == nil {
		if final, err := filepath.EvalSymlinks(path); err == nil {
			path, _ = filepath.Abs(final)
		}
		exePath = filepath.Dir(path)
	}

	flag.StringVar(&gocRoot, "gocroot", gocRoot, "GopherC compiler path (GOCROOT)")
	flag.BoolVar(&silent, "s", silent, "silent mode")
	flag.BoolVar(&verbose, "v", verbose, "verbose")
	flag.Parse()

	if gocRoot == "" {
		gocRoot = filepath.Clean(filepath.Join(exePath, "..", ".."))
	}
}

func PrintDefaults() {
	setupFlags()
	fmt.Println("goc bind [path]")
	flag.PrintDefaults()
}
